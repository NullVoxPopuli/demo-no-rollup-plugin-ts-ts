"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const walk_sync_1 = __importDefault(require("walk-sync"));
const path_1 = __importDefault(require("path"));
const minimatch_1 = __importDefault(require("minimatch"));
function normalizeFileExt(fileName) {
    return fileName.replace(/\.ts|\.hbs|\.gts|\.gjs$/, '.js');
}
function publicEntrypoints(args) {
    return {
        name: 'addon-modules',
        async buildStart() {
            let matches = (0, walk_sync_1.default)(args.srcDir, {
                globs: [...args.include, '**/*.hbs', '**/*.ts', '**/*.gts', '**/*.gjs'],
            });
            for (let name of matches) {
                // the matched file, but with the extension swapped with .js
                let normalizedName = normalizeFileExt(name);
                // anything that doesn't match the users patterns, and wasn't a template-only
                // component needs to be emitted "as-is" so that other plugins may handle it.
                let isTO = isTemplateOnly(matches, name);
                let isHbs = path_1.default.extname(name) === '.hbs';
                // hbs for-colocated components is handled by the rollup-hbs-plugin
                // hbs for template-only components is handled in the isTO block
                if (isHbs && !isTO) {
                    continue;
                }
                // these chunks matched are **/*.hbs glob and are
                // guaranteed to not have any corresponding file as a co-located component would have.
                if (isTO) {
                    this.emitFile({
                        type: 'chunk',
                        id: path_1.default.join(args.srcDir, normalizedName),
                        fileName: normalizedName,
                    });
                    continue;
                }
                // anything that matches one of the user's patterns is definitely emitted
                let isUserDefined = args.include.some((pattern) => (0, minimatch_1.default)(name, pattern));
                // additionally, we want to emit chunks where the pattern matches the supported
                // file extensions above (TS, GTS, etc) as if they were already the built JS.
                let wouldMatchIfBuilt = args.include.some((pattern) => (0, minimatch_1.default)(normalizedName, pattern));
                if (isUserDefined || wouldMatchIfBuilt) {
                    this.emitFile({
                        type: 'chunk',
                        id: path_1.default.join(args.srcDir, name),
                        fileName: normalizedName,
                    });
                    continue;
                }
            }
        },
    };
}
exports.default = publicEntrypoints;
function isTemplateOnly(matches, filePath) {
    let isHbs = path_1.default.extname(filePath) === '.hbs';
    if (!isHbs)
        return false;
    let correspondingFileGlob = path_1.default.join(path_1.default.dirname(filePath), path_1.default.basename(filePath).replace(/hbs$/, '*'));
    let relatedFiles = matches.filter((match) => (0, minimatch_1.default)(match, correspondingFileGlob));
    let isTO = relatedFiles.filter((x) => x !== filePath).length === 0;
    return isTO;
}
//# sourceMappingURL=rollup-public-entrypoints.js.map