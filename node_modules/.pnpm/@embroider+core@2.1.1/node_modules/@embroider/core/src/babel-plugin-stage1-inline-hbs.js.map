{"version":3,"file":"babel-plugin-stage1-inline-hbs.js","sourceRoot":"","sources":["babel-plugin-stage1-inline-hbs.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n  This babel plugins is responsible for running custom AST transform in inline\n  templates. It doesn't compile to wire format, because it runs at stage1.\n*/\n\nimport { join } from 'path';\nimport type { TemplateCompiler } from './template-compiler-common';\nimport type { NodePath } from '@babel/traverse';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\nimport { templateCompilationModules } from '@embroider/shared-internals';\n\nexport default function make<Opts>(getCompiler: (opts: Opts) => TemplateCompiler) {\n  interface State {\n    opts: Opts;\n    file: {\n      code: string;\n      opts: {\n        filename: string;\n      };\n    };\n    templateCompiler: TemplateCompiler | undefined;\n  }\n\n  function stage1InlineHBSTransform(babel: typeof Babel): unknown {\n    let t = babel.types;\n    return {\n      visitor: {\n        TaggedTemplateExpression(path: NodePath<t.TaggedTemplateExpression>, state: State) {\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('tag').referencesImport(module, exportedName)) {\n              handleTagged(path, state, t);\n            }\n          }\n        },\n        CallExpression(path: NodePath<t.CallExpression>, state: State) {\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('callee').referencesImport(module, exportedName)) {\n              handleCalled(path, state, t);\n            }\n          }\n        },\n      },\n    };\n  }\n\n  stage1InlineHBSTransform._parallelBabel = {\n    requireFile: __filename,\n  };\n\n  stage1InlineHBSTransform.baseDir = function () {\n    return join(__dirname, '..');\n  };\n\n  function handleTagged(path: NodePath<t.TaggedTemplateExpression>, state: State, t: typeof Babel.types) {\n    if (path.node.quasi.expressions.length) {\n      throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');\n    }\n    let template = path.node.quasi.quasis.map(quasi => quasi.value.cooked).join('');\n    let compiled = compiler(state).applyTransforms(state.file.opts.filename, template);\n    path.get('quasi').replaceWith(t.templateLiteral([t.templateElement({ raw: compiled, cooked: compiled })], []));\n  }\n\n  function handleCalled(path: NodePath<t.CallExpression>, state: State, t: typeof Babel.types) {\n    let { template, insertRuntimeErrors } = getCallArguments(path);\n    let compilerInstance = compiler(state);\n\n    let compiled: string;\n    try {\n      compiled = compilerInstance.applyTransforms(state.file.opts.filename, template);\n    } catch (err) {\n      if (insertRuntimeErrors) {\n        // in stage 1 we just leave the bad template in place (we were only\n        // trying to run transforms and re-emit hbs), so that it will be handled\n        // at stage3 instead.\n        return;\n      }\n      throw err;\n    }\n    (path.get('arguments')[0] as NodePath).replaceWith(t.stringLiteral(compiled));\n  }\n\n  function compiler(state: State) {\n    if (!state.templateCompiler) {\n      state.templateCompiler = getCompiler(state.opts);\n    }\n    return state.templateCompiler;\n  }\n\n  function getCallArguments(path: NodePath<t.CallExpression>): { template: string; insertRuntimeErrors: boolean } {\n    let [template, options] = path.node.arguments;\n\n    let insertRuntimeErrors =\n      options?.type === 'ObjectExpression' &&\n      options.properties.some(\n        prop =>\n          prop.type === 'ObjectProperty' &&\n          prop.computed === false &&\n          prop.key.type === 'Identifier' &&\n          prop.key.name === 'insertRuntimeErrors' &&\n          prop.value.type === 'BooleanLiteral' &&\n          prop.value.value\n      );\n\n    return {\n      template: getTemplateString(template, path),\n      insertRuntimeErrors,\n    };\n  }\n\n  return stage1InlineHBSTransform;\n}\n\nfunction getTemplateString(template: any, path: NodePath<t.CallExpression>): string {\n  if (template?.type === 'StringLiteral') {\n    return template.value;\n  }\n  // treat inert TemplateLiteral (without subexpressions) like a StringLiteral\n  if (template?.type === 'TemplateLiteral' && !template.expressions.length) {\n    return template.quasis[0].value.cooked;\n  }\n  throw path.buildCodeFrameError('hbs accepts only a string literal argument');\n}\n"]}