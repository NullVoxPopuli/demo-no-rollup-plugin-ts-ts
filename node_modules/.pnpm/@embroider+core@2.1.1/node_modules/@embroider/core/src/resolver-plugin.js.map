{"version":3,"file":"resolver-plugin.js","sourceRoot":"","sources":["resolver-plugin.ts"],"names":[],"mappings":";;;;;;AAAA,uCAA0C;AAC1C,uDAA6F;AAC7F,gEAAuC;AAI1B,QAAA,cAAc,GAAG,IAAA,yBAAc,EAAC,CAAC,eAAsC,EAAE,EAAE;IACtF,OAAO;QACL,IAAI,EAAE,6BAA6B;QACnC,KAAK,CAAC,SAAS,CACb,EAAU,EACV,QAA4B,EAC5B,QAEC;YAED,IAAI,CAAC,QAAQ,EAAE;gBACb,OAAO,IAAI,CAAC;aACb;YAED,IAAI,UAAU,GAAG,WAAW,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;YAEpE,QAAQ,UAAU,CAAC,MAAM,EAAE;gBACzB,KAAK,UAAU;oBACb,oEAAoE;oBACpE,qEAAqE;oBACrE,wEAAwE;oBACxE,uEAAuE;oBACvE,mBAAmB;oBACnB,OAAO,wBAAwB,UAAU,CAAC,SAAS,EAAE,CAAC;gBACxD,KAAK,UAAU;oBACb,sEAAsE;oBACtE,OAAO,IAAI,CAAC;gBACd,KAAK,aAAa;oBAChB,OAAO,IAAI,CAAC;gBACd;oBACE,MAAM,IAAA,sBAAW,EAAC,UAAU,CAAC,CAAC;aACjC;QACH,CAAC;QACD,KAAK,CAAC,IAAI,CAAC,EAAU;YACnB,IAAI,EAAE,CAAC,UAAU,CAAC,uBAAuB,CAAC,EAAE;gBAC1C,IAAI,UAAU,GAAG,EAAE,CAAC,KAAK,CAAC,uBAAuB,CAAC,MAAM,CAAC,CAAC;gBAC1D,OAAO,IAAA,8BAAY,EAAC,EAAE,UAAU,EAAE,CAAC,CAAC;aACrC;QACH,CAAC;KACF,CAAC;AACJ,CAAC,CAAC,CAAC;AAEH,IAAI,IAKS,CAAC;AAEd,SAAS,WAAW,CAAC,QAAgB,EAAE,eAAsC;IAC3E,yEAAyE;IACzE,wEAAwE;IACxE,0EAA0E;IAC1E,gBAAgB;IAChB,IAAI,QAAQ,GAAG,CAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,QAAQ,MAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,0BAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC;IACrG,IAAI,GAAG,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;IAC9B,OAAO,QAAQ,CAAC;AAClB,CAAC","sourcesContent":["import { createUnplugin } from 'unplugin';\nimport { externalShim, Options as ResolverPluginOptions, Resolver } from './module-resolver';\nimport assertNever from 'assert-never';\n\nexport { ResolverPluginOptions };\n\nexport const resolverPlugin = createUnplugin((resolverOptions: ResolverPluginOptions) => {\n  return {\n    name: 'unplugin-embroider-resolver',\n    async resolveId(\n      id: string,\n      importer: string | undefined,\n      _options: {\n        isEntry: boolean;\n      }\n    ) {\n      if (!importer) {\n        return null;\n      }\n\n      let resolution = resolverFor(importer, resolverOptions).resolve(id);\n\n      switch (resolution.result) {\n        case 'external':\n          // according to the docs we should be allowed to return `{ external:\n          // true, id: resolution.specifier }` here and that would take care of\n          // externalizing. But due to https://github.com/unjs/unplugin/issues/238\n          // that doesn't work, so we will generate our own runtime stubs via the\n          // load hook below.\n          return `@embroider/externals/${resolution.specifier}`;\n        case 'continue':\n          // null is the \"defer to other plugins and default resolution\" outcome\n          return null;\n        case 'redirect-to':\n          return null;\n        default:\n          throw assertNever(resolution);\n      }\n    },\n    async load(id: string) {\n      if (id.startsWith('@embroider/externals/')) {\n        let moduleName = id.slice('@embroider/externals/'.length);\n        return externalShim({ moduleName });\n      }\n    },\n  };\n});\n\nlet prev:\n  | {\n      importer: string;\n      resolver: Resolver;\n    }\n  | undefined;\n\nfunction resolverFor(importer: string, resolverOptions: ResolverPluginOptions): Resolver {\n  // as a very simple cache, reuse the same Resolver if we're still working\n  // from the same importer as the last call. We'd expect that is a common\n  // case, and we can avoid re-discovering things like the owning package of\n  // the importer.\n  let resolver = prev?.importer === importer ? prev.resolver : new Resolver(importer, resolverOptions);\n  prev = { importer, resolver };\n  return resolver;\n}\n"]}