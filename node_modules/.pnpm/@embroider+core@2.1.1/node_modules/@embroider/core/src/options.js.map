{"version":3,"file":"options.js","sourceRoot":"","sources":["options.ts"],"names":[],"mappings":";;;AA6GA,SAAgB,mBAAmB,CAAC,OAAiB;IACnD,IAAI,QAAQ,GAAG;QACb,aAAa,EAAE,KAAK;QACpB,eAAe,EAAE,KAAK;QACtB,gBAAgB,EAAE,KAAK;QACvB,aAAa,EAAE,EAAE;QACjB,cAAc,EAAE,EAAE;QAClB,SAAS,EAAE,EAAE;QACb,WAAW,EAAE,EAAE;QACf,uBAAuB,EAAE,eAAkC;KAC5D,CAAC;IACF,IAAI,OAAO,EAAE;QACX,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;KACzC;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC;AAfD,kDAeC","sourcesContent":["export default interface Options {\n  // When true, we statically resolve all template helpers at build time. This\n  // causes unused helpers to be left out of the build (\"tree shaking\" of\n  // helpers).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticHelpers?: boolean;\n\n  // When true, we statically resolve all modifiers at build time. This\n  // causes unused modifiers to be left out of the build (\"tree shaking\" of\n  // modifiers).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticModifiers?: boolean;\n\n  // When true, we statically resolve all components at build time. This causes\n  // unused components to be left out of the build (\"tree shaking\" of\n  // components).\n  //\n  // Defaults to false, which gives you greater compatibility with classic Ember\n  // apps at the cost of bigger builds.\n  //\n  // Enabling this is a prerequisite for route splitting.\n  staticComponents?: boolean;\n\n  // Enables per-route code splitting. Any route names that match these patterns\n  // will be split out of the initial app payload. If you use this, you must\n  // also add @embroider/router to your app. See [@embroider/router's\n  // README](https://github.com/embroider-build/embroider/blob/main/packages/router/README.md)\n  splitAtRoutes?: (RegExp | string)[];\n\n  // Every file within your application's `app` directory is categorized as a\n  // component, helper, modifier, route, route template, controller, or \"other\".\n  //\n  // This option lets you decide which \"other\" files should be loaded\n  // statically. By default, all \"other\" files will be included in the build and\n  // registered with Ember's runtime loader, because we can't know if somebody\n  // is going to try to access them dynamically via Ember's resolver or AMD\n  // runtime `require`.\n  //\n  // If you know that your files are only ever imported, you can list them here\n  // and then they will only be included exactly where they're needed.\n  //\n  // Provide a list of directories or files relative to `/app`. For example\n  //\n  //     staticAppPaths: ['lib']\n  //\n  // means that everything under your-project/app/lib will be loaded statically.\n  //\n  // This option has no effect on components (which are governed by\n  // staticComponents), helpers (which are governed by staticHelpers), modifiers\n  // (which are governed by staticModifiers) or the route-specific files (routes,\n  // route templates, and controllers which are governed by splitAtRoutes).\n  staticAppPaths?: string[];\n\n  // By default, all modules that get imported into the app go through Babel, so\n  // that all code will conform with your Babel targets. This option allows you\n  // to turn Babel off for a particular package. You might need this to work\n  // around a transpiler bug or you might use this as a build-performance\n  // optimization if you've manually verified that a particular package doesn't\n  // need transpilation to be safe in your target browsers.\n  skipBabel?: { package: string; semverRange?: string }[];\n\n  // This is a performance optimization that can help you avoid the \"Your build\n  // is slower because some babel plugins are non-serializable\" penalty. If you\n  // provide the locations of known non-serializable objects, we can discover\n  // them and make them serializable.\n  //\n  // resolve is a list of paths to resolve, in a chain. This lets you resolve\n  // your dependencies' dependencies, like: resolve: ['your-dependency',\n  // 'inner-dependency/lib/transform']\n  //\n  // useMethod optionally lets you pick which property within the module to use.\n  // If not provided, we use the module.exports itself.\n  pluginHints?: { resolve: string[]; useMethod?: string }[];\n\n  // Our addons' implicit-modules and implicit-test-modules are not necessarily\n  // resolvable directly from the app, but the meaning of those\n  // backward-compatibility features is \"the app should import this module\". So\n  // we need some strategy for making them importable by the app. We can either\n  // turn those imports into complete relative paths, or leave them as package\n  // names:\n  //\n  // relativePaths:\n  //\n  //   import('./node_modules/intermediate/node_modules/some-addon/thing.js')\n  //\n  // packageNames:\n  //\n  //   import('some-addon/thing.js')\n  //\n  // When building under a tool like webpack, the relativePaths are safe and\n  // always work, although they can be uglier to look at when debugging in\n  // development.\n  //\n  // When building under a tool like snowpack, the package names can be easier\n  // to work with because you already have web-bundles per package, and can't\n  // necessarily address arbitrary places on the filesystem.\n  //\n  // Defaults to \"relativePaths\".\n  implicitModulesStrategy?: 'packageNames' | 'relativePaths';\n}\n\nexport function optionsWithDefaults(options?: Options): Required<Options> {\n  let defaults = {\n    staticHelpers: false,\n    staticModifiers: false,\n    staticComponents: false,\n    splitAtRoutes: [],\n    staticAppPaths: [],\n    skipBabel: [],\n    pluginHints: [],\n    implicitModulesStrategy: 'relativePaths' as 'relativePaths',\n  };\n  if (options) {\n    return Object.assign(defaults, options);\n  }\n  return defaults;\n}\n"]}