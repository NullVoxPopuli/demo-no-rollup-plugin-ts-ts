"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefineExpression = exports.isDynamicImportExpression = exports.isImportSyncExpression = void 0;
const path_1 = require("path");
const babel_import_util_1 = require("babel-import-util");
const crypto_1 = require("crypto");
const fs_extra_1 = require("fs-extra");
const shared_internals_1 = require("@embroider/shared-internals");
const js_handlebars_1 = require("./js-handlebars");
const module_resolver_1 = require("./module-resolver");
const assert_never_1 = __importDefault(require("assert-never"));
function isImportSyncExpression(t, path) {
    if (!path ||
        !path.isCallExpression() ||
        path.node.callee.type !== 'Identifier' ||
        !path.get('callee').referencesImport('@embroider/macros', 'importSync')) {
        return false;
    }
    const args = path.node.arguments;
    return Array.isArray(args) && args.length === 1 && t.isStringLiteral(args[0]);
}
exports.isImportSyncExpression = isImportSyncExpression;
function isDynamicImportExpression(t, path) {
    if (!path || !path.isCallExpression() || path.node.callee.type !== 'Import') {
        return false;
    }
    const args = path.node.arguments;
    return Array.isArray(args) && args.length === 1 && t.isStringLiteral(args[0]);
}
exports.isDynamicImportExpression = isDynamicImportExpression;
function isDefineExpression(t, path) {
    // should we allow nested defines, or stop at the top level?
    if (!path.isCallExpression() || path.node.callee.type !== 'Identifier' || path.node.callee.name !== 'define') {
        return false;
    }
    const args = path.node.arguments;
    // only match define with 3 arguments define(name: string, deps: string[], cb: Function);
    return (Array.isArray(args) &&
        args.length === 3 &&
        t.isStringLiteral(args[0]) &&
        t.isArrayExpression(args[1]) &&
        t.isFunction(args[2]));
}
exports.isDefineExpression = isDefineExpression;
function main(babel) {
    let t = babel.types;
    return {
        visitor: {
            Program: {
                enter(path, state) {
                    let opts = ensureOpts(state);
                    state.resolver = new module_resolver_1.Resolver(path.hub.file.opts.filename, opts);
                    let adder = new babel_import_util_1.ImportUtil(t, path);
                    addExtraImports(adder, t, path, opts.extraImports);
                },
                exit(path, state) {
                    for (let child of path.get('body')) {
                        if (child.isImportDeclaration() || child.isExportNamedDeclaration() || child.isExportAllDeclaration()) {
                            rewriteTopLevelImport(child, state);
                        }
                    }
                },
            },
            CallExpression(path, state) {
                if (isImportSyncExpression(t, path) || isDynamicImportExpression(t, path)) {
                    const [source] = path.get('arguments');
                    resolve(source.node.value, true, state, newSpecifier => {
                        source.replaceWith(t.stringLiteral(newSpecifier));
                    });
                    return;
                }
                // Should/can we make this early exit when the first define was found?
                if (!isDefineExpression(t, path)) {
                    return;
                }
                let pkg = state.resolver.owningPackage();
                if (pkg && pkg.isV2Ember() && !pkg.meta['auto-upgraded']) {
                    throw new Error(`The file ${state.resolver.originalFilename} in package ${pkg.name} tried to use AMD define. Native V2 Ember addons are forbidden from using AMD define, they must use ECMA export only.`);
                }
                const dependencies = path.node.arguments[1];
                const specifiers = dependencies.elements.slice();
                specifiers.push(path.node.arguments[0]);
                for (const source of specifiers) {
                    if (!source) {
                        continue;
                    }
                    if (source.type !== 'StringLiteral') {
                        throw path.buildCodeFrameError(`expected only string literal arguments`);
                    }
                    if (source.value === 'exports' || source.value === 'require') {
                        // skip "special" AMD dependencies
                        continue;
                    }
                    resolve(source.value, false, state, newSpecifier => {
                        source.value = newSpecifier;
                    });
                }
            },
        },
    };
}
exports.default = main;
function rewriteTopLevelImport(path, state) {
    const { source } = path.node;
    if (source === null || source === undefined) {
        return;
    }
    resolve(source.value, false, state, newSpecifier => {
        source.value = newSpecifier;
    });
}
main.baseDir = function () {
    return (0, path_1.join)(__dirname, '..');
};
function addExtraImports(adder, t, path, extraImports) {
    for (let { absPath, target, runtimeName } of extraImports) {
        if (absPath === path.hub.file.opts.filename) {
            if (runtimeName) {
                path.node.body.unshift(amdDefine(t, adder, path, target, runtimeName));
            }
            else {
                adder.importForSideEffect(target);
            }
        }
    }
}
function amdDefine(t, adder, path, target, runtimeName) {
    let value = t.callExpression(adder.import(path, '@embroider/macros', 'importSync'), [t.stringLiteral(target)]);
    return t.expressionStatement(t.callExpression(t.memberExpression(t.identifier('window'), t.identifier('define')), [
        t.stringLiteral(runtimeName),
        t.functionExpression(null, [], t.blockStatement([t.returnStatement(value)])),
    ]));
}
function ensureOpts(state) {
    let { opts } = state;
    if ('adjustImportsOptionsPath' in opts) {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        return (state.opts = { ...require(opts.adjustImportsOptionsPath), ...require(opts.relocatedFilesPath) });
    }
    return opts;
}
function makeExternal(specifier, sourceFile, opts) {
    let target = (0, path_1.join)(opts.externalsDir, specifier + '.js');
    atomicWrite(target, externalTemplate({
        runtimeName: specifier,
    }));
    return (0, shared_internals_1.explicitRelative)((0, path_1.dirname)(sourceFile), target.slice(0, -3));
}
function atomicWrite(path, content) {
    if ((0, fs_extra_1.pathExistsSync)(path)) {
        return;
    }
    let suffix = (0, crypto_1.randomBytes)(8).toString('hex');
    (0, fs_extra_1.outputFileSync)(path + suffix, content);
    try {
        (0, fs_extra_1.renameSync)(path + suffix, path);
    }
    catch (err) {
        // windows throws EPERM for concurrent access. For us it's not an error
        // condition because the other thread is writing the exact same value we
        // would have.
        if (err.code !== 'EPERM') {
            throw err;
        }
    }
}
function makeMissingModule(specifier, sourceFile, opts) {
    let target = (0, path_1.join)(opts.externalsDir, 'missing', specifier + '.js');
    atomicWrite(target, dynamicMissingModule({
        moduleName: specifier,
    }));
    return (0, shared_internals_1.explicitRelative)((0, path_1.dirname)(sourceFile), target.slice(0, -3));
}
const dynamicMissingModule = (0, js_handlebars_1.compile)(`
  throw new Error('Could not find module \`{{{js-string-escape moduleName}}}\`');
`);
const externalTemplate = (0, js_handlebars_1.compile)(`
{{#if (eq runtimeName "require")}}
const m = window.requirejs;
{{else}}
const m = window.require("{{{js-string-escape runtimeName}}}");
{{/if}}
{{!-
  There are plenty of hand-written AMD defines floating around
  that lack this, and they will break when other build systems
  encounter them.

  As far as I can tell, Ember's loader was already treating this
  case as a module, so in theory we aren't breaking anything by
  marking it as such when other packagers come looking.

  todo: get review on this part.
-}}
if (m.default && !m.__esModule) {
  m.__esModule = true;
}
module.exports = m;
`);
function resolve(specifier, isDynamic, state, setter) {
    let resolution = state.resolver.resolve(specifier, isDynamic);
    let newSpecifier;
    switch (resolution.result) {
        case 'continue':
            return;
        case 'external':
            newSpecifier = makeExternal(resolution.specifier, state.resolver.filename, ensureOpts(state));
            break;
        case 'redirect-to':
            newSpecifier = resolution.specifier;
            break;
        case 'runtime-failure':
            newSpecifier = makeMissingModule(resolution.specifier, state.resolver.filename, ensureOpts(state));
            break;
        default:
            throw (0, assert_never_1.default)(resolution);
    }
    if (newSpecifier) {
        setter(newSpecifier);
    }
}
//# sourceMappingURL=babel-plugin-adjust-imports.js.map