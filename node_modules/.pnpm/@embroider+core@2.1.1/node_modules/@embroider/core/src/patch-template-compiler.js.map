{"version":3,"file":"patch-template-compiler.js","sourceRoot":"","sources":["patch-template-compiler.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodePath } from '@babel/traverse';\nimport { transform, types as t } from '@babel/core';\n\nfunction parseVersion(templateCompilerPath: string, source: string): { major: number; minor: number; patch: number } {\n  // ember-template-compiler.js contains a comment that indicates what version it is for\n  // that looks like:\n\n  /*!\n   * @overview  Ember - JavaScript Application Framework\n   * @copyright Copyright 2011-2020 Tilde Inc. and contributors\n   *            Portions Copyright 2006-2011 Strobe Inc.\n   *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.\n   * @license   Licensed under MIT license\n   *            See https://raw.github.com/emberjs/ember.js/master/LICENSE\n   * @version   3.25.1\n   */\n\n  let version = source.match(/@version\\s+([\\d\\.]+)/);\n  if (!version || !version[1]) {\n    throw new Error(\n      `Could not find version string in \\`${templateCompilerPath}\\`. Maybe we don't support your ember-source version?`\n    );\n  }\n\n  let numbers = version[1].split('.');\n  let major = parseInt(numbers[0], 10);\n  let minor = parseInt(numbers[1], 10);\n  let patch = parseInt(numbers[2], 10);\n\n  return { major, minor, patch };\n}\n\nfunction emberVersionGte(templateCompilerPath: string, source: string, major: number, minor: number): boolean {\n  let actual = parseVersion(templateCompilerPath, source);\n\n  return actual.major > major || (actual.major === major && actual.minor >= minor);\n}\n\nexport function patch(source: string, templateCompilerPath: string): string {\n  let version = parseVersion(templateCompilerPath, source);\n\n  if (\n    emberVersionGte(templateCompilerPath, source, 3, 26) ||\n    (version.major === 3 && version.minor === 25 && version.patch >= 2) ||\n    (version.major === 3 && version.minor === 24 && version.patch >= 3)\n  ) {\n    // no modifications are needed after\n    // https://github.com/emberjs/ember.js/pull/19426 and backported to\n    // 3.26.0-beta.3, 3.25.2, 3.24.3\n    return source;\n  }\n\n  let replacedVar = false;\n  let patchedSource;\n\n  let needsAngleBracketPrinterFix =\n    emberVersionGte(templateCompilerPath, source, 3, 12) && !emberVersionGte(templateCompilerPath, source, 3, 17);\n\n  if (needsAngleBracketPrinterFix) {\n    // here we are stripping off the first `var Ember;`. That one small change\n    // lets us crack open the file and get access to its internal loader, because\n    // we can give it our own predefined `Ember` variable instead, which it will\n    // use and put `Ember.__loader` onto.\n    //\n    // on ember 3.12 through 3.16 (which use variants of glimmer-vm 0.38.5) we\n    // also apply a patch to the printer in @glimmer/syntax to fix\n    // https://github.com/glimmerjs/glimmer-vm/pull/941/files because it can\n    // really bork apps under embroider, and we'd like to support at least all\n    // active LTS versions of ember.\n    patchedSource = transform(source, {\n      plugins: [\n        function () {\n          return {\n            visitor: {\n              VariableDeclarator(path: NodePath<t.VariableDeclarator>) {\n                let id = path.node.id;\n                if (id.type === 'Identifier' && id.name === 'Ember' && !replacedVar) {\n                  replacedVar = true;\n                  path.remove();\n                }\n              },\n              CallExpression: {\n                enter(path: NodePath<t.CallExpression>, state: BabelState) {\n                  let callee = path.get('callee');\n                  if (!callee.isIdentifier() || callee.node.name !== 'define') {\n                    return;\n                  }\n                  let firstArg = path.get('arguments')[0];\n                  if (!firstArg.isStringLiteral() || firstArg.node.value !== '@glimmer/syntax') {\n                    return;\n                  }\n                  state.definingGlimmerSyntax = path;\n                },\n                exit(path: NodePath<t.CallExpression>, state: BabelState) {\n                  if (state.definingGlimmerSyntax === path) {\n                    state.definingGlimmerSyntax = false;\n                  }\n                },\n              },\n              FunctionDeclaration: {\n                enter(path: NodePath<t.FunctionDeclaration>, state: BabelState) {\n                  if (!state.definingGlimmerSyntax) {\n                    return;\n                  }\n                  let id = path.get('id');\n                  if (id.isIdentifier() && id.node.name === 'build') {\n                    state.declaringBuildFunction = path;\n                  }\n                },\n                exit(path: NodePath<t.FunctionDeclaration>, state: BabelState) {\n                  if (state.declaringBuildFunction === path) {\n                    state.declaringBuildFunction = false;\n                  }\n                },\n              },\n              SwitchCase: {\n                enter(path: NodePath<t.SwitchCase>, state: BabelState) {\n                  if (!state.definingGlimmerSyntax) {\n                    return;\n                  }\n                  let test = path.get('test');\n                  if (test.isStringLiteral() && test.node.value === 'ElementNode') {\n                    state.caseElementNode = path;\n                  }\n                },\n                exit(path: NodePath<t.SwitchCase>, state: BabelState) {\n                  if (state.caseElementNode === path) {\n                    state.caseElementNode = false;\n                  }\n                },\n              },\n              IfStatement(path: NodePath<t.IfStatement>, state: BabelState) {\n                if (!state.caseElementNode) {\n                  return;\n                }\n                let test = path.get('test');\n                // the place we want is the only if with a computed member\n                // expression predicate.\n                if (test.isMemberExpression() && test.node.computed) {\n                  path.node.alternate = t.ifStatement(\n                    t.memberExpression(t.identifier('ast'), t.identifier('selfClosing')),\n                    t.blockStatement([\n                      t.expressionStatement(\n                        t.callExpression(t.memberExpression(t.identifier('output'), t.identifier('push')), [\n                          t.stringLiteral(' />'),\n                        ])\n                      ),\n                    ]),\n                    path.node.alternate\n                  );\n                }\n              },\n            },\n          };\n        },\n      ],\n    })!.code!;\n  } else {\n    // applies to < 3.12 and >= 3.17\n    //\n    // here we are stripping off the first `var Ember;`. That one small change\n    // lets us crack open the file and get access to its internal loader, because\n    // we can give it our own predefined `Ember` variable instead, which it will\n    // use and put `Ember.__loader` onto.\n    patchedSource = transform(source, {\n      generatorOpts: {\n        compact: true,\n      },\n      plugins: [\n        function () {\n          return {\n            visitor: {\n              VariableDeclarator(path: NodePath<t.VariableDeclarator>) {\n                let id = path.node.id;\n                if (id.type === 'Identifier' && id.name === 'Ember' && !replacedVar) {\n                  replacedVar = true;\n                  path.remove();\n                }\n              },\n            },\n          };\n        },\n      ],\n    })!.code!;\n  }\n\n  if (!replacedVar) {\n    throw new Error(\n      `didn't find expected source in ${templateCompilerPath}. Maybe we don't support your ember-source version?`\n    );\n  }\n\n  return `\n      let Ember = {};\n      ${patchedSource};\n      module.exports.Ember = Ember;\n  `;\n}\n\ninterface BabelState {\n  definingGlimmerSyntax: NodePath | false;\n  declaringBuildFunction: NodePath | false;\n  caseElementNode: NodePath | false;\n}\n"]}