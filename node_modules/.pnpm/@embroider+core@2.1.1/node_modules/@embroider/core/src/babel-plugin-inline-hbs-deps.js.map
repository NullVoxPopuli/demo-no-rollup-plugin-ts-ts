{"version":3,"file":"babel-plugin-inline-hbs-deps.js","sourceRoot":"","sources":["babel-plugin-inline-hbs-deps.ts"],"names":[],"mappings":"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","sourcesContent":["import type { NodePath } from '@babel/traverse';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\nimport { join } from 'path';\nimport type { TemplateCompiler } from './template-compiler-common';\nimport { ResolvedDep } from './resolver';\nimport { templateCompilationModules } from '@embroider/shared-internals';\nimport { ImportUtil } from 'babel-import-util';\n\n/*\n  In order to coordinate with babel-plugin-ember-template-compilation, we need\n  to give it a `precompile` function that, as a side-effect, captures the\n  dependencies needed within the current file. We do this coordination via this\n  module-scoped variable, which is safe given Javascript's single-threaded\n  nature and babel's synchronicity.\n*/\nlet currentState: State | undefined;\n\n/*\n  This is the precompile function you should pass to\n  babel-plugin-ember-template-compilation.\n*/\nexport function precompile(templateSource: string, options: Record<string, unknown>) {\n  if (!currentState) {\n    throw new Error(\n      `bug: babel-plugin-ember-template-compilation and babel-plugin-inline-hbs-deps aren't coordinating correctly`\n    );\n  }\n  let { compiled, dependencies } = compiler(currentState).precompile(templateSource, {\n    filename: currentState.file.opts.filename,\n    ...options,\n  });\n  for (let dep of dependencies) {\n    currentState.dependencies.set(dep.runtimeName, dep);\n  }\n  return compiled;\n}\n\ninterface State {\n  opts: {};\n  file: {\n    code: string;\n    opts: {\n      filename: string;\n    };\n  };\n  dependencies: Map<string, ResolvedDep>;\n  getCompiler: (opts: any) => TemplateCompiler;\n  templateCompiler: TemplateCompiler | undefined;\n  adder: ImportUtil;\n  emittedCallExpressions: Set<t.Node>;\n}\n\nexport default function make(getCompiler: (opts: any) => TemplateCompiler) {\n  function inlineHBSTransform(babel: typeof Babel): unknown {\n    let t = babel.types;\n    return {\n      visitor: {\n        Program: {\n          enter(path: NodePath<t.Program>, state: State) {\n            state.dependencies = new Map();\n            state.adder = new ImportUtil(t, path);\n            state.emittedCallExpressions = new Set();\n            state.getCompiler = getCompiler;\n            currentState = state;\n          },\n          exit(path: NodePath<t.Program>, state: State) {\n            // we are responsible for rewriting all usages of all the\n            // templateCompilationModules to standardize on\n            // @ember/template-compilation, so all imports other than that one\n            // need to be cleaned up here.\n            for (let moduleConfig of templateCompilationModules) {\n              if (moduleConfig.module !== '@ember/template-compilation') {\n                state.adder.removeImport(moduleConfig.module, moduleConfig.exportedName);\n              }\n            }\n            let counter = 0;\n            for (let dep of state.dependencies.values()) {\n              path.node.body.unshift(amdDefine(dep.runtimeName, counter, t));\n              path.node.body.unshift(\n                t.importDeclaration(\n                  [t.importDefaultSpecifier(t.identifier(`a${counter++}`))],\n                  t.stringLiteral(dep.path)\n                )\n              );\n            }\n            currentState = undefined;\n          },\n        },\n        TaggedTemplateExpression(path: NodePath<t.TaggedTemplateExpression>, state: State) {\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('tag').referencesImport(module, exportedName)) {\n              handleTagged(path, state, t);\n            }\n          }\n        },\n        CallExpression(path: NodePath<t.CallExpression>, state: State) {\n          if (state.emittedCallExpressions.has(path.node)) {\n            return;\n          }\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('callee').referencesImport(module, exportedName)) {\n              handleCalled(path, state, t);\n            }\n          }\n        },\n      },\n    };\n  }\n\n  inlineHBSTransform._parallelBabel = {\n    requireFile: __filename,\n  };\n\n  inlineHBSTransform.baseDir = function () {\n    return join(__dirname, '..');\n  };\n\n  function handleTagged(path: NodePath<t.TaggedTemplateExpression>, state: State, t: typeof Babel.types) {\n    if (path.node.quasi.expressions.length) {\n      throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');\n    }\n    let template = path.node.quasi.quasis.map(quasi => quasi.value.cooked).join('');\n    let args: t.Expression[] = [t.stringLiteral(template)];\n\n    let locals: t.Identifier[] = [\n      // TODO: this is where lexically scoped dependencies go\n    ];\n    let opts = precompileOpts(locals, t);\n    if (opts) {\n      args.push(opts);\n    }\n\n    let newCallExpression = t.callExpression(\n      state.adder.import(path, '@ember/template-compilation', 'precompileTemplate'),\n      args\n    );\n\n    state.emittedCallExpressions.add(newCallExpression);\n    path.replaceWith(newCallExpression);\n  }\n\n  function handleCalled(path: NodePath<t.CallExpression>, state: State, t: typeof Babel.types) {\n    let newCallExpression = t.callExpression(\n      state.adder.import(path, '@ember/template-compilation', 'precompileTemplate'),\n      path.node.arguments\n    );\n    state.emittedCallExpressions.add(newCallExpression);\n    path.replaceWith(newCallExpression);\n  }\n\n  function precompileOpts(locals: t.Identifier[], t: typeof Babel.types) {\n    if (locals.length > 0) {\n      return t.objectExpression([\n        t.objectProperty(\n          t.identifier('scope'),\n          t.arrowFunctionExpression(\n            [],\n            t.objectExpression(locals.map(name => t.objectProperty(name, name, false, true)))\n          )\n        ),\n      ]);\n    }\n  }\n\n  function amdDefine(runtimeName: string, importCounter: number, t: typeof Babel.types) {\n    return t.expressionStatement(\n      t.callExpression(t.memberExpression(t.identifier('window'), t.identifier('define')), [\n        t.stringLiteral(runtimeName),\n        t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.identifier(`a${importCounter}`))])),\n      ])\n    );\n  }\n  return inlineHBSTransform;\n}\n\nfunction compiler(state: State) {\n  if (!state.templateCompiler) {\n    state.templateCompiler = state.getCompiler(state.opts);\n  }\n  return state.templateCompiler;\n}\n"]}