import type { NodePath } from '@babel/traverse';
import type * as Babel from '@babel/core';
import type { types as t } from '@babel/core';
import { Options, Resolver } from './module-resolver';
interface State {
    resolver: Resolver;
    opts: Options | DeflatedOptions;
}
export { Options };
export interface DeflatedOptions {
    adjustImportsOptionsPath: string;
    relocatedFilesPath: string;
}
declare type BabelTypes = typeof t;
declare type DefineExpressionPath = NodePath<t.CallExpression> & {
    node: t.CallExpression & {
        arguments: [t.StringLiteral, t.ArrayExpression, Function];
    };
};
export declare function isImportSyncExpression(t: BabelTypes, path: NodePath<any>): boolean;
export declare function isDynamicImportExpression(t: BabelTypes, path: NodePath<any>): boolean;
export declare function isDefineExpression(t: BabelTypes, path: NodePath<any>): path is DefineExpressionPath;
export default function main(babel: typeof Babel): {
    visitor: {
        Program: {
            enter(path: NodePath<Babel.types.Program>, state: State): void;
            exit(path: NodePath<Babel.types.Program>, state: State): void;
        };
        CallExpression(path: NodePath<Babel.types.CallExpression>, state: State): void;
    };
};
