{"version":3,"file":"describe-exports.js","sourceRoot":"","sources":["describe-exports.ts"],"names":[],"mappings":";;;;;;AAAA,sCAAsD;AACtD,+DAAqD;AACrD,sCAAyC;AACzC,gEAAuC;AAEvC,SAAgB,eAAe,CAC7B,IAAY,EACZ,iBAAmC;IAEnC,IAAI,GAAG,GAAG,IAAA,YAAK,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;IACzC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,EAAE;QAC/B,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;KAC3D;IACD,IAAI,KAAK,GAAgB,IAAI,GAAG,EAAE,CAAC;IACnC,IAAI,gBAAgB,GAAG,KAAK,CAAC;IAE7B,IAAA,kBAAQ,EAAC,GAAG,EAAE;QACZ,sBAAsB,CAAC,IAAwC;YAC7D,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBACrC,QAAQ,IAAI,CAAC,IAAI,EAAE;oBACjB,KAAK,iBAAiB,CAAC;oBACvB,KAAK,0BAA0B;wBAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,KAAK,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;wBAE5F,IAAI,IAAI,KAAK,SAAS,EAAE;4BACtB,gBAAgB,GAAG,IAAI,CAAC;yBACzB;6BAAM;4BACL,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;yBACjB;wBACD,MAAM;oBACR,KAAK,wBAAwB;wBAC3B,kDAAkD;wBAClD,MAAM;oBACR;wBACE,IAAA,sBAAW,EAAC,IAAI,CAAC,CAAC;iBACrB;aACF;YACD,IAAI,YAAC,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;gBAClD,KAAK,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE;oBAClD,IAAI,YAAC,CAAC,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;wBAC1B,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;qBACxB;iBACF;aACF;QACH,CAAC;QACD,wBAAwB,CAAC,KAA2C;YAClE,gBAAgB,GAAG,IAAI,CAAC;QAC1B,CAAC;KACF,CAAC,CAAC;IACH,OAAO,EAAE,KAAK,EAAE,gBAAgB,EAAE,CAAC;AACrC,CAAC;AA7CD,0CA6CC","sourcesContent":["import { parse, TransformOptions } from '@babel/core';\nimport traverse, { NodePath } from '@babel/traverse';\nimport { types as t } from '@babel/core';\nimport assertNever from 'assert-never';\n\nexport function describeExports(\n  code: string,\n  babelParserConfig: TransformOptions\n): { names: Set<string>; hasDefaultExport: boolean } {\n  let ast = parse(code, babelParserConfig);\n  if (!ast || ast.type !== 'File') {\n    throw new Error(`bug in embroider/core describe-exports`);\n  }\n  let names: Set<string> = new Set();\n  let hasDefaultExport = false;\n\n  traverse(ast, {\n    ExportNamedDeclaration(path: NodePath<t.ExportNamedDeclaration>) {\n      for (let spec of path.node.specifiers) {\n        switch (spec.type) {\n          case 'ExportSpecifier':\n          case 'ExportNamespaceSpecifier':\n            const name = spec.exported.type === 'Identifier' ? spec.exported.name : spec.exported.value;\n\n            if (name === 'default') {\n              hasDefaultExport = true;\n            } else {\n              names.add(name);\n            }\n            break;\n          case 'ExportDefaultSpecifier':\n            // this is in the types but was never standardized\n            break;\n          default:\n            assertNever(spec);\n        }\n      }\n      if (t.isVariableDeclaration(path.node.declaration)) {\n        for (let dec of path.node.declaration.declarations) {\n          if (t.isIdentifier(dec.id)) {\n            names.add(dec.id.name);\n          }\n        }\n      }\n    },\n    ExportDefaultDeclaration(_path: NodePath<t.ExportDefaultDeclaration>) {\n      hasDefaultExport = true;\n    },\n  });\n  return { names, hasDefaultExport };\n}\n"]}