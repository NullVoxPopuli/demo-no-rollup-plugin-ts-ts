"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolverPlugin = void 0;
const unplugin_1 = require("unplugin");
const module_resolver_1 = require("./module-resolver");
const assert_never_1 = __importDefault(require("assert-never"));
exports.resolverPlugin = (0, unplugin_1.createUnplugin)((resolverOptions) => {
    return {
        name: 'unplugin-embroider-resolver',
        async resolveId(id, importer, _options) {
            if (!importer) {
                return null;
            }
            let resolution = resolverFor(importer, resolverOptions).resolve(id);
            switch (resolution.result) {
                case 'external':
                    // according to the docs we should be allowed to return `{ external:
                    // true, id: resolution.specifier }` here and that would take care of
                    // externalizing. But due to https://github.com/unjs/unplugin/issues/238
                    // that doesn't work, so we will generate our own runtime stubs via the
                    // load hook below.
                    return `@embroider/externals/${resolution.specifier}`;
                case 'continue':
                    // null is the "defer to other plugins and default resolution" outcome
                    return null;
                case 'redirect-to':
                    return null;
                default:
                    throw (0, assert_never_1.default)(resolution);
            }
        },
        async load(id) {
            if (id.startsWith('@embroider/externals/')) {
                let moduleName = id.slice('@embroider/externals/'.length);
                return (0, module_resolver_1.externalShim)({ moduleName });
            }
        },
    };
});
let prev;
function resolverFor(importer, resolverOptions) {
    // as a very simple cache, reuse the same Resolver if we're still working
    // from the same importer as the last call. We'd expect that is a common
    // case, and we can avoid re-discovering things like the owning package of
    // the importer.
    let resolver = (prev === null || prev === void 0 ? void 0 : prev.importer) === importer ? prev.resolver : new module_resolver_1.Resolver(importer, resolverOptions);
    prev = { importer, resolver };
    return resolver;
}
//# sourceMappingURL=resolver-plugin.js.map