{"version":3,"file":"multi-tree-diff.js","sourceRoot":"","sources":["multi-tree-diff.ts"],"names":[],"mappings":"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","sourcesContent":["import FSTree, { Operation, Entry } from 'fs-tree-diff';\nimport lodashIsEqual from 'lodash/isEqual';\n\nexport interface InputTree {\n  walk(): Entry[];\n  mayChange: boolean;\n}\n\n// tells you which of your inTrees (by index) resulted in the given output file\nexport class Sources {\n  constructor(\n    private combinedEntries: ReturnType<MultiTreeDiff['combinedEntries']>,\n    private combinedOwners: MultiTreeDiff['combinedOwners']\n  ) {}\n  get(relativePath: string): number[] {\n    return this.combinedOwners.get(this.combinedEntries.get(relativePath)!)!;\n  }\n}\n\n// this is how you control what happens when multiple trees try to output the\n// same path. Your merger function is told which trees are trying to collide,\n// and you say which ones will be allowed to influence the output. More than one\n// winner is allowed because sometimes you will be merging their contents.\nexport type Merger = (treeIndices: number[]) => number[];\n\nexport default class MultiTreeDiff {\n  private prevEntries: Entry[][] | undefined;\n  private prevCombined: FSTree = new FSTree();\n\n  // tracks which input Entry is owned by which input tree\n  private owners: WeakMap<Entry, number> = new WeakMap();\n\n  // tracks which output Entry is owned by which set of input trees. This is\n  // different from `owners` because merging is possible.\n  private combinedOwners: WeakMap<Entry, number[]> = new WeakMap();\n\n  constructor(private inTrees: InputTree[], private merger: Merger) {}\n\n  private allEntries(): Entry[][] {\n    let result = this.inTrees.map((tree, index) => {\n      if (!tree.mayChange && this.prevEntries && this.prevEntries[index]) {\n        return this.prevEntries[index];\n      }\n      return tree.walk();\n    });\n    this.prevEntries = result;\n    return result;\n  }\n\n  private candidates(entries: Entry[][]): Map<string, Entry[]> {\n    let result: Map<string, Entry[]> = new Map();\n    for (let [treeIndex, treeEntries] of entries.entries()) {\n      for (let entry of treeEntries) {\n        let list = result.get(entry.relativePath);\n        if (!list) {\n          list = [];\n          result.set(entry.relativePath, list);\n        }\n        list.push(entry);\n        this.owners.set(entry, treeIndex);\n      }\n    }\n    return result;\n  }\n\n  private combinedEntries(candidates: Map<string, Entry[]>): Map<string, Entry> {\n    let result: Map<string, Entry> = new Map();\n    for (let [relativePath, entries] of candidates.entries()) {\n      if (entries.length === 1) {\n        let [entry] = entries;\n        // no collision, simple case.\n        result.set(relativePath, entry);\n        this.combinedOwners.set(entry, [this.owners.get(entry)!]);\n      } else {\n        // collision, apply merge logic\n        let winners = this.merger(entries.map(e => this.owners.get(e)!));\n        if (winners.length === 1) {\n          // single winner, no merging\n          let winner = entries.find(e => this.owners.get(e) === winners[0])!;\n          result.set(relativePath, winner);\n          this.combinedOwners.set(winner, winners);\n        } else {\n          // multiple winners, must synthesize a combined entry\n          let winningEntries = entries.filter(e => winners.includes(this.owners.get(e)!));\n          let combinedEntry: Entry = {\n            relativePath,\n            size: winningEntries.reduce((accum, entry) => {\n              return accum + (entry.size || 0);\n            }, 0),\n            mtime: winningEntries.reduce((accum: undefined | number | Date, entry) => {\n              return latest(accum, entry.mtime);\n            }, undefined),\n            isDirectory() {\n              return winningEntries.reduce((isDir: boolean, entry) => isDir || entry.isDirectory(), false);\n            },\n          };\n          result.set(relativePath, combinedEntry);\n          this.combinedOwners.set(combinedEntry, winners);\n        }\n      }\n    }\n    return result;\n  }\n\n  update(): { ops: Operation[]; sources: Sources } {\n    let combinedEntries = this.combinedEntries(this.candidates(this.allEntries()));\n\n    // FSTree requires the entries to be sorted and uniq. We already have\n    // uniqueness because we're taking them out of a map. And here we do the\n    // sort.\n    let combinedEntriesList = [...combinedEntries.values()].sort(compareByRelativePath);\n    let newFSTree = FSTree.fromEntries(combinedEntriesList);\n    let ops = this.prevCombined.calculatePatch(newFSTree, isEqual(this.combinedOwners));\n    this.prevCombined = newFSTree;\n    return { ops, sources: new Sources(combinedEntries, this.combinedOwners) };\n  }\n}\n\nfunction compareByRelativePath(entryA: Entry, entryB: Entry) {\n  let pathA = entryA.relativePath;\n  let pathB = entryB.relativePath;\n\n  if (pathA < pathB) {\n    return -1;\n  } else if (pathA > pathB) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction isEqual(owners: WeakMap<Entry, number[]>) {\n  return function (a: Entry, b: Entry) {\n    return FSTree.defaultIsEqual(a, b) && lodashIsEqual(owners.get(a), owners.get(b));\n  };\n}\n\nfunction latest(a: number | Date | undefined, b: number | Date | undefined): number | undefined | Date {\n  if (a == null) {\n    return b;\n  }\n  if (b == null) {\n    return a;\n  }\n  if (a instanceof Date) {\n    a = a.getTime();\n  }\n  if (b instanceof Date) {\n    b = b.getTime();\n  }\n  return Math.max(a, b);\n}\n"]}