{"version":3,"file":"babel-plugin-inline-hbs.js","sourceRoot":"","sources":["babel-plugin-inline-hbs.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n  This plugin is used only for Ember < 3.27. For newer Ember's we have a\n  different implementation that shares the standard\n  babel-plugin-ember-template-compilation and supports passing Javascript\n  lexically scoped names into templates.\n*/\n\nimport type { types as t } from '@babel/core';\nimport type * as Babel from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport { join } from 'path';\nimport type { TemplateCompiler } from './template-compiler-common';\nimport { parse } from '@babel/core';\nimport { ResolvedDep } from './resolver';\nimport { ImportUtil } from 'babel-import-util';\nimport { templateCompilationModules } from '@embroider/shared-internals';\n\ntype BabelTypes = typeof t;\n\ninterface State<O> {\n  opts: O;\n  file: {\n    code: string;\n    opts: {\n      filename: string;\n    };\n  };\n  dependencies: Map<string, ResolvedDep>;\n  templateCompiler: TemplateCompiler | undefined;\n  adder: ImportUtil;\n}\n\nexport default function make<O>(getCompiler: (opts: O) => TemplateCompiler) {\n  function inlineHBSTransform(babel: typeof Babel): Babel.PluginObj<State<O>> {\n    let t = babel.types;\n    return {\n      visitor: {\n        Program: {\n          enter(path: NodePath<t.Program>, state: State<O>) {\n            state.dependencies = new Map();\n            state.adder = new ImportUtil(t, path);\n          },\n          exit(path: NodePath<t.Program>, state: State<O>) {\n            for (let { module, exportedName } of templateCompilationModules) {\n              state.adder.removeImport(module, exportedName);\n            }\n            let counter = 0;\n            for (let dep of state.dependencies.values()) {\n              path.node.body.unshift(amdDefine(dep.runtimeName, counter, t));\n              path.node.body.unshift(\n                t.importDeclaration(\n                  [t.importDefaultSpecifier(t.identifier(`a${counter++}`))],\n                  t.stringLiteral(dep.path)\n                )\n              );\n            }\n          },\n        },\n        TaggedTemplateExpression(path: NodePath<t.TaggedTemplateExpression>, state: State<O>) {\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('tag').referencesImport(module, exportedName)) {\n              handleTagged(path, state, t);\n            }\n          }\n        },\n        CallExpression(path: NodePath<t.CallExpression>, state: State<O>) {\n          for (let { module, exportedName } of templateCompilationModules) {\n            if (path.get('callee').referencesImport(module, exportedName)) {\n              handleCalled(path, state, t);\n            }\n          }\n        },\n      },\n    };\n  }\n\n  inlineHBSTransform._parallelBabel = {\n    requireFile: __filename,\n  };\n\n  inlineHBSTransform.baseDir = function () {\n    return join(__dirname, '..');\n  };\n\n  function handleTagged(path: NodePath<t.TaggedTemplateExpression>, state: State<O>, t: BabelTypes) {\n    if (path.node.quasi.expressions.length) {\n      throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');\n    }\n    let template = path.node.quasi.quasis.map(quasi => quasi.value.cooked).join('');\n    let { compiled, dependencies } = compiler(state).precompile(template, { filename: state.file.opts.filename });\n    for (let dep of dependencies) {\n      state.dependencies.set(dep.runtimeName, dep);\n    }\n\n    path.replaceWith(\n      t.callExpression(state.adder.import(path, '@ember/template-factory', 'createTemplateFactory'), [\n        jsonLiteral(compiled, t),\n      ])\n    );\n  }\n\n  function handleCalled(path: NodePath<t.CallExpression>, state: State<O>, t: BabelTypes) {\n    let { template, insertRuntimeErrors } = getCallArguments(path);\n    let compilerInstance = compiler(state);\n\n    let result: ReturnType<TemplateCompiler['precompile']>;\n    try {\n      result = compilerInstance.precompile(template, { filename: state.file.opts.filename, insertRuntimeErrors });\n    } catch (err) {\n      if (insertRuntimeErrors) {\n        path.replaceWith(\n          t.callExpression(\n            t.functionExpression(\n              null,\n              [],\n              t.blockStatement([\n                t.throwStatement(t.newExpression(t.identifier('Error'), [t.stringLiteral(err.message)])),\n              ])\n            ),\n            []\n          )\n        );\n        return;\n      }\n      throw err;\n    }\n    let { compiled, dependencies } = result;\n    for (let dep of dependencies) {\n      state.dependencies.set(dep.runtimeName, dep);\n    }\n    path.replaceWith(\n      t.callExpression(state.adder.import(path, '@ember/template-factory', 'createTemplateFactory'), [\n        jsonLiteral(compiled, t),\n      ])\n    );\n  }\n\n  function jsonLiteral(value: unknown | undefined, t: BabelTypes) {\n    if (typeof value === 'undefined') {\n      return t.identifier('undefined');\n    }\n    let ast = parse(`a(${value})`, {}) as t.File;\n    let statement = ast.program.body[0] as t.ExpressionStatement;\n    let expression = statement.expression as t.CallExpression;\n    return expression.arguments[0];\n  }\n\n  function compiler(state: State<O>) {\n    if (!state.templateCompiler) {\n      state.templateCompiler = getCompiler(state.opts);\n    }\n    return state.templateCompiler;\n  }\n\n  function amdDefine(runtimeName: string, importCounter: number, t: BabelTypes) {\n    return t.expressionStatement(\n      t.callExpression(t.memberExpression(t.identifier('window'), t.identifier('define')), [\n        t.stringLiteral(runtimeName),\n        t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.identifier(`a${importCounter}`))])),\n      ])\n    );\n  }\n\n  function getTemplateString(template: any, path: NodePath<t.CallExpression>): string {\n    if (template?.type === 'StringLiteral') {\n      return template.value;\n    }\n    // treat inert TemplateLiteral (without subexpressions) like a StringLiteral\n    if (template?.type === 'TemplateLiteral' && !template.expressions.length) {\n      return template.quasis[0].value.cooked;\n    }\n    throw path.buildCodeFrameError('hbs accepts only a string literal argument');\n  }\n\n  function getCallArguments(path: NodePath<t.CallExpression>): { template: string; insertRuntimeErrors: boolean } {\n    let [template, options] = path.node.arguments;\n\n    let insertRuntimeErrors =\n      options?.type === 'ObjectExpression' &&\n      options.properties.some(\n        prop =>\n          prop.type === 'ObjectProperty' &&\n          prop.computed === false &&\n          prop.key.type === 'Identifier' &&\n          prop.key.name === 'insertRuntimeErrors' &&\n          prop.value.type === 'BooleanLiteral' &&\n          prop.value.value\n      );\n\n    return {\n      template: getTemplateString(template, path),\n      insertRuntimeErrors,\n    };\n  }\n\n  return inlineHBSTransform;\n}\n"]}