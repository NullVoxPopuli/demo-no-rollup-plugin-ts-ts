{"version":3,"file":"babel-plugin-adjust-imports.js","sourceRoot":"","sources":["babel-plugin-adjust-imports.ts"],"names":[],"mappings":"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","sourcesContent":["import { join, dirname } from 'path';\nimport type { NodePath } from '@babel/traverse';\nimport type * as Babel from '@babel/core';\nimport type { types as t } from '@babel/core';\nimport { ImportUtil } from 'babel-import-util';\nimport { randomBytes } from 'crypto';\nimport { outputFileSync, pathExistsSync, renameSync } from 'fs-extra';\nimport { explicitRelative } from '@embroider/shared-internals';\nimport { compile } from './js-handlebars';\nimport { Options, Resolver } from './module-resolver';\nimport assertNever from 'assert-never';\n\ninterface State {\n  resolver: Resolver;\n  opts: Options | DeflatedOptions;\n}\n\nexport { Options };\n\nexport interface DeflatedOptions {\n  adjustImportsOptionsPath: string;\n  relocatedFilesPath: string;\n}\n\ntype BabelTypes = typeof t;\n\ntype DefineExpressionPath = NodePath<t.CallExpression> & {\n  node: t.CallExpression & {\n    arguments: [t.StringLiteral, t.ArrayExpression, Function];\n  };\n};\n\nexport function isImportSyncExpression(t: BabelTypes, path: NodePath<any>) {\n  if (\n    !path ||\n    !path.isCallExpression() ||\n    path.node.callee.type !== 'Identifier' ||\n    !path.get('callee').referencesImport('@embroider/macros', 'importSync')\n  ) {\n    return false;\n  }\n\n  const args = path.node.arguments;\n  return Array.isArray(args) && args.length === 1 && t.isStringLiteral(args[0]);\n}\n\nexport function isDynamicImportExpression(t: BabelTypes, path: NodePath<any>) {\n  if (!path || !path.isCallExpression() || path.node.callee.type !== 'Import') {\n    return false;\n  }\n\n  const args = path.node.arguments;\n  return Array.isArray(args) && args.length === 1 && t.isStringLiteral(args[0]);\n}\n\nexport function isDefineExpression(t: BabelTypes, path: NodePath<any>): path is DefineExpressionPath {\n  // should we allow nested defines, or stop at the top level?\n  if (!path.isCallExpression() || path.node.callee.type !== 'Identifier' || path.node.callee.name !== 'define') {\n    return false;\n  }\n\n  const args = path.node.arguments;\n\n  // only match define with 3 arguments define(name: string, deps: string[], cb: Function);\n  return (\n    Array.isArray(args) &&\n    args.length === 3 &&\n    t.isStringLiteral(args[0]) &&\n    t.isArrayExpression(args[1]) &&\n    t.isFunction(args[2])\n  );\n}\n\nexport default function main(babel: typeof Babel) {\n  let t = babel.types;\n  return {\n    visitor: {\n      Program: {\n        enter(path: NodePath<t.Program>, state: State) {\n          let opts = ensureOpts(state);\n          state.resolver = new Resolver(path.hub.file.opts.filename, opts);\n          let adder = new ImportUtil(t, path);\n          addExtraImports(adder, t, path, opts.extraImports);\n        },\n        exit(path: NodePath<t.Program>, state: State) {\n          for (let child of path.get('body')) {\n            if (child.isImportDeclaration() || child.isExportNamedDeclaration() || child.isExportAllDeclaration()) {\n              rewriteTopLevelImport(child, state);\n            }\n          }\n        },\n      },\n      CallExpression(path: NodePath<t.CallExpression>, state: State) {\n        if (isImportSyncExpression(t, path) || isDynamicImportExpression(t, path)) {\n          const [source] = path.get('arguments');\n          resolve((source.node as any).value, true, state, newSpecifier => {\n            source.replaceWith(t.stringLiteral(newSpecifier));\n          });\n          return;\n        }\n\n        // Should/can we make this early exit when the first define was found?\n        if (!isDefineExpression(t, path)) {\n          return;\n        }\n\n        let pkg = state.resolver.owningPackage();\n        if (pkg && pkg.isV2Ember() && !pkg.meta['auto-upgraded']) {\n          throw new Error(\n            `The file ${state.resolver.originalFilename} in package ${pkg.name} tried to use AMD define. Native V2 Ember addons are forbidden from using AMD define, they must use ECMA export only.`\n          );\n        }\n\n        const dependencies = path.node.arguments[1];\n\n        const specifiers = dependencies.elements.slice();\n        specifiers.push(path.node.arguments[0]);\n\n        for (const source of specifiers) {\n          if (!source) {\n            continue;\n          }\n\n          if (source.type !== 'StringLiteral') {\n            throw path.buildCodeFrameError(`expected only string literal arguments`);\n          }\n\n          if (source.value === 'exports' || source.value === 'require') {\n            // skip \"special\" AMD dependencies\n            continue;\n          }\n\n          resolve(source.value, false, state, newSpecifier => {\n            source.value = newSpecifier;\n          });\n        }\n      },\n    },\n  };\n}\n\nfunction rewriteTopLevelImport(\n  path: NodePath<t.ImportDeclaration | t.ExportNamedDeclaration | t.ExportAllDeclaration>,\n  state: State\n) {\n  const { source } = path.node;\n  if (source === null || source === undefined) {\n    return;\n  }\n\n  resolve(source.value, false, state, newSpecifier => {\n    source.value = newSpecifier;\n  });\n}\n\n(main as any).baseDir = function () {\n  return join(__dirname, '..');\n};\n\nfunction addExtraImports(\n  adder: ImportUtil,\n  t: BabelTypes,\n  path: NodePath<t.Program>,\n  extraImports: Required<Options>['extraImports']\n) {\n  for (let { absPath, target, runtimeName } of extraImports) {\n    if (absPath === path.hub.file.opts.filename) {\n      if (runtimeName) {\n        path.node.body.unshift(amdDefine(t, adder, path, target, runtimeName));\n      } else {\n        adder.importForSideEffect(target);\n      }\n    }\n  }\n}\n\nfunction amdDefine(t: BabelTypes, adder: ImportUtil, path: NodePath<t.Program>, target: string, runtimeName: string) {\n  let value = t.callExpression(adder.import(path, '@embroider/macros', 'importSync'), [t.stringLiteral(target)]);\n  return t.expressionStatement(\n    t.callExpression(t.memberExpression(t.identifier('window'), t.identifier('define')), [\n      t.stringLiteral(runtimeName),\n      t.functionExpression(null, [], t.blockStatement([t.returnStatement(value)])),\n    ])\n  );\n}\n\nfunction ensureOpts(state: State): Options {\n  let { opts } = state;\n  if ('adjustImportsOptionsPath' in opts) {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    return (state.opts = { ...require(opts.adjustImportsOptionsPath), ...require(opts.relocatedFilesPath) });\n  }\n  return opts;\n}\n\nfunction makeExternal(specifier: string, sourceFile: string, opts: Options): string {\n  let target = join(opts.externalsDir, specifier + '.js');\n  atomicWrite(\n    target,\n    externalTemplate({\n      runtimeName: specifier,\n    })\n  );\n  return explicitRelative(dirname(sourceFile), target.slice(0, -3));\n}\n\nfunction atomicWrite(path: string, content: string) {\n  if (pathExistsSync(path)) {\n    return;\n  }\n  let suffix = randomBytes(8).toString('hex');\n  outputFileSync(path + suffix, content);\n  try {\n    renameSync(path + suffix, path);\n  } catch (err: any) {\n    // windows throws EPERM for concurrent access. For us it's not an error\n    // condition because the other thread is writing the exact same value we\n    // would have.\n    if (err.code !== 'EPERM') {\n      throw err;\n    }\n  }\n}\n\nfunction makeMissingModule(specifier: string, sourceFile: string, opts: Options): string {\n  let target = join(opts.externalsDir, 'missing', specifier + '.js');\n  atomicWrite(\n    target,\n    dynamicMissingModule({\n      moduleName: specifier,\n    })\n  );\n  return explicitRelative(dirname(sourceFile), target.slice(0, -3));\n}\n\nconst dynamicMissingModule = compile(`\n  throw new Error('Could not find module \\`{{{js-string-escape moduleName}}}\\`');\n`) as (params: { moduleName: string }) => string;\n\nconst externalTemplate = compile(`\n{{#if (eq runtimeName \"require\")}}\nconst m = window.requirejs;\n{{else}}\nconst m = window.require(\"{{{js-string-escape runtimeName}}}\");\n{{/if}}\n{{!-\n  There are plenty of hand-written AMD defines floating around\n  that lack this, and they will break when other build systems\n  encounter them.\n\n  As far as I can tell, Ember's loader was already treating this\n  case as a module, so in theory we aren't breaking anything by\n  marking it as such when other packagers come looking.\n\n  todo: get review on this part.\n-}}\nif (m.default && !m.__esModule) {\n  m.__esModule = true;\n}\nmodule.exports = m;\n`) as (params: { runtimeName: string }) => string;\n\nfunction resolve(specifier: string, isDynamic: boolean, state: State, setter: (specifier: string) => void) {\n  let resolution = state.resolver.resolve(specifier, isDynamic);\n  let newSpecifier: string | undefined;\n  switch (resolution.result) {\n    case 'continue':\n      return;\n    case 'external':\n      newSpecifier = makeExternal(resolution.specifier, state.resolver.filename, ensureOpts(state));\n      break;\n    case 'redirect-to':\n      newSpecifier = resolution.specifier;\n      break;\n    case 'runtime-failure':\n      newSpecifier = makeMissingModule(resolution.specifier, state.resolver.filename, ensureOpts(state));\n      break;\n    default:\n      throw assertNever(resolution);\n  }\n  if (newSpecifier) {\n    setter(newSpecifier);\n  }\n}\n"]}